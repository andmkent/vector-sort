#lang racket/base

;; This file contains a simple implementation of introsort for
;; Racket's mutable vectors.

;; Introsort is a hybrid sorting algorithm that begins
;; with quicksort and switches to heap sort at a certain
;; recursive depth to avoid quicksort's occassional
;; worst-case performance (giving us O(n log n) worst case).

;; Insertion sort is also used by quicksort when the size of
;; the array section being considered is smaller than some
;; (perhaps arbitrary) threshold.

;; Note: the sorting functions are written entirely within
;; a macro so we can precompile certain common cases for better
;; performance.


;; introsort pseudo code used to write this implementation
;; from Wikipedia's introsort article:
;;
;; procedure sort(A : array):
;;   let maxdepth = ⌊log(length(A))⌋ × 2
;;   introsort(A, maxdepth)
;;
;; procedure introsort(A, maxdepth):
;;    n ← length(A)
;;    if n ≤ 1:
;;        return  // base case
;;    else if maxdepth = 0:
;;        heapsort(A)
;;    else:
;;        p ← partition(A)
;;        introsort(A[0:p], maxdepth - 1)
;;        introsort(A[p+1:n], maxdepth - 1)


;; This code was hastily written by Andrew Kent -- sorry.
;; Pull requests welcome =)

(require (for-syntax racket/base
                     racket/syntax)
         racket/unsafe/ops
         racket/vector)

(provide raw-vector-sort
         raw-vector-sort!)


;; - - - - - - - - - - - - - - - - - - -
;; Handy Macros/Shorthands
;; - - - - - - - - - - - - - - - - - - -


;; common vector/integer ops & shorthands
(define-syntax i+ (make-rename-transformer #'unsafe-fx+))
(define-syntax i- (make-rename-transformer #'unsafe-fx-))
(define-syntax-rule (i*2 i) (unsafe-fxlshift i 1))
(define-syntax-rule (i/2 i) (unsafe-fxrshift i 1))
(define-syntax i< (make-rename-transformer #'unsafe-fx<))
(define-syntax i≤ (make-rename-transformer #'unsafe-fx<=))
(define-syntax i= (make-rename-transformer #'unsafe-fx=))
(define-syntax vref (make-rename-transformer #'unsafe-vector-ref))
(define-syntax vset! (make-rename-transformer #'unsafe-vector-set!))
(define-syntax cached-value (make-rename-transformer #'unsafe-cdr))
(define-syntax cached-key (make-rename-transformer #'unsafe-car))

#|
(define-syntax i+ (make-rename-transformer #'+))
(define-syntax i- (make-rename-transformer #'-))
(define-syntax-rule (i*2 i) (* i 2))
(define-syntax-rule (i/2 i) (quotient i 2))
(define-syntax i< (make-rename-transformer #'<))
(define-syntax i≤ (make-rename-transformer #'<=))
(define-syntax i= (make-rename-transformer #'=))
(define-syntax vref (make-rename-transformer #'vector-ref))
(define-syntax vset! (make-rename-transformer #'vector-set!))
(define-syntax cached-value (make-rename-transformer #'cdr))
(define-syntax cached-key (make-rename-transformer #'car))


|#

;; vector value swap macro
(define-syntax-rule (swap! A i j)
  (let ([tmp (vref A i)])
    (vset! A i (vref A j))
    (vset! A j tmp)))

;; generic heapsort helpers
(define-syntax-rule (parent i) (i/2 (i- i 1)))
(define-syntax-rule (lchild i) (i+ (i*2 i) 1))
(define-syntax-rule (rchild i) (i+ (i*2 i) 2))


;; while macro for concise incrementing/decrementing of variables
(define-syntax (while stx)
  (syntax-case stx ()
    [(_ cond body ... #:++ i #:else return)
     #'(let loop ([i i])
         (if cond (let () body ... (loop (i+ i 1))) return))]
    [(_ cond body ... #:++ i)
     #'(let loop ([i i])
         (if cond (let () body ... (loop (i+ i 1))) (void)))]
    [(_ cond body ... #:-- i #:else return)
     #'(let loop ([i i])
         (if cond (let () body ... (loop (i- i 1))) return))]
    [(_ cond body ... #:-- i)
     #'(let loop ([i i])
         (if cond (let () body ... (loop (i- i 1))) (void)))]))



;; - - - - - - - - - - - - - - - - - - -
;; Magic Numbers
;; - - - - - - - - - - - - - - - - - - -

;; Constants that determine which sort is used when

;; at what size should quicksort resort to insertion sort?
(define insertion-sort-cutoff 27)
;; how deep should quicksort go before switching to 
(define (calc-max-depth len)
  3 #;(i*2 (inexact->exact (round (log len)))))


;; - - - - - - - - - - - - - - - - - - -
;; The Sorting Definition Macro
;; - - - - - - - - - - - - - - - - - - -


;; sort definitions are generated by this macro so we can get
;; optimizations for special/common cases (i.e. no extract-key function,
;; using a primitive compare function like '<', etc)
(define-syntax (introsort-body stx)
  
  ;; - - - - - - - - - - - - - - - - - - -
  ;; key caching operations
  ;; - - - - - - - - - - - - - - - - - - -
  (define (maybe-cache-keys cache? extract-key A len)
    (if cache?
        (with-syntax ([A A]
                      [len len]
                      [extract-key extract-key])
          #'(let loop ([i 0])
              (when (i< i len)
                (let* ([val (vref A i)]
                       [key (extract-key val)])
                  (vset! A i (cons key val))
                  (loop (i+ i 1))))))
        #'(void)))
  
  (define (maybe-uncache-keys cache? A len)
    (if cache?
        (with-syntax ([A A] [len len])
          #'(let loop ([i 0])
              (when (i< i len)
                (vset! A i (cached-value (vref A i)))
                (loop (i+ i 1)))))
        #'(void)))
  
  ;; - - - - - - - - - - - - - - - - - - -
  ;; insertion sort
  ;; - - - - - - - - - - - - - - - - - - -
  
  (define (insertion-sort-def A <?)
    (with-syntax ([A A]
                  [<? <?]
                  [i (generate-temporary 'i)]
                  [idx (generate-temporary 'idx)])
      #'(λ (low high)
          ;; hd is the new head of the subsection of the
          ;; vector (i.e. it contains the next element to insert)
          (define hd (i- high 1))
          (while (i≤ low hd)
                 ;; the next value to be inserted
                 (define val (vref A hd))
                 ;; the current index we examining to see
                 ;; where val should go
                 (define i (i+ hd 1))
                 (while (and (i≤ i high) (<? (vref A i) val))
                        (vset! A (i- i 1) (vref A i))
                        #:++ i
                        #:else (let ([val-idx (i- i 1)])
                                 (when (i< hd val-idx)
                                   (vset! A val-idx val))))
                 
                 #:-- hd))))
  ;; - - - - - - - - - - - - - - - - - - -
  ;; heapsort!
  ;; - - - - - - - - - - - - - - - - - - -
  (define (heapsort-def A <?)
    (with-syntax ([A A]
                  [<? <?])
      #'(λ (low high)
          (define (sift-down! root end)
            (define lc (lchild root))
            (define rc (i+ lc 1))
            (when (i≤ lc end)
              (define child 
                (cond [(and (i≤ rc end)
                            (<? (vref A lc) (vref A rc)))
                       rc]
                      [else lc]))
              (when (<? (vref A root) (vref A child))
                (swap! A root child))
              (sift-down! child end)))

          ;; heapify
          (let ([i (i/2 (i- high 1))])
            (while (i≤ low i)
                   (sift-down! i high)
                   #:-- i))
          
          (let ([end high])
            (while (i< low end)
                   (swap! A low end)
                   (sift-down! low (i- end 1))
                   #:-- end)))))
  
  ;; - - - - - - - - - - - - - - - - - - -
  ;; quicksort helpers
  ;; - - - - - - - - - - - - - - - - - - -
  
  ;; select-pivot!
  ;; median of three pivot selection. Sorts low, middle, and high,
  ;; places the pivot in (high - 1) and returns the pivot's value.
  (define (select-pivot-def A <?)
    (with-syntax ([A A] [<? <?])
      #'(λ (low high)
          (let ([middle (i/2 (i+ low high))])
            (when (<? (vref A middle) (vref A low))
              (swap! A low middle))
            (when (<? (vref A high) (vref A low))
              (swap! A low high))
            (when (<? (vref A high) (vref A middle))
              (swap! A middle high))
            ;; put pivot in high - 1
            (swap! A middle (i- high 1))
            (vref A (i- high 1))))))
  
  ;; partition!
  ;; partition algorithm used by quicksort, returns location
  ;; of pivot in partitioned section
  (define (partition-def select-pivot! A <?)
    (with-syntax ([select-pivot! select-pivot!]
                  [A A]
                  [<? <?])
      #'(λ (low high)
          ;; select and place pivot in (high - 1)
          (let ([pivot-val (select-pivot! low high)])
            ;; increment/decrement i/j, swapping when necessary
            (let loop ([i (i+ low 1)]
                       [j (i- high 2)])
              (let ([i (while (<? (vref A i) pivot-val) #:++ i #:else i)]
                    [j (while (<? pivot-val (vref A j)) #:-- j #:else j)])
                (cond
                  [(i< i j) (swap! A i j)
                            (loop (i+ i 1) (i- j 1))]
                  [else
                   ;; place pivot in the correct place
                   (swap! A i (i- high 1))
                   ;; return pivot location
                   i])))))))
  ;; - - - - - - - - - - - - - - - - - - -
  ;; introsort!
  ;; - - - - - - - - - - - - - - - - - - -
  (define (introsort-def introsort!
                         partition!
                         insertion-sort!
                         heapsort!
                         A)
    (with-syntax ([introsort! introsort!]
                  [partition! partition!]
                  [insertion-sort! insertion-sort!]
                  [heapsort! heapsort!]
                  [A A])
      #'(λ (low high fuel)
          (cond
            [(i< high (i+ low insertion-sort-cutoff))
             (insertion-sort! low high)]
            [(i= fuel 0) (heapsort! low high)]
            [else
             (let ([pivot (partition! low high)])
               (introsort! low (i- pivot 1) (i- fuel 1))
               (introsort! (i+ pivot 1) high (i- fuel 1)))]))))
  (syntax-case stx ()
    [(_ A less-than? #:key extract-key #:cache-keys? cache-keys?)
     (with-syntax* ([len (generate-temporary 'len)]
                    [<? (generate-temporary '<?)]
                    [maybe-cache-keys! (generate-temporary 'maybe-cache-keys!)]
                    [maybe-uncache-keys! (generate-temporary 'maybe-uncache-keys!)]
                    [insertion-sort! (generate-temporary 'insertion-sort!)]
                    [select-pivot! (generate-temporary 'select-pivot!)]
                    [partition! (generate-temporary 'partition!)]
                    [introsort! (generate-temporary 'introsort!)]
                    [heapsort! (generate-temporary 'heapsort!)])
       #`(let ()
           ;; comparison function that includes any needed
           ;; key/cache reasoning
           (define-syntax-rule (<? x y)
             #,(cond
                 [(syntax->datum #'cache-keys?)
                  #'(less-than? (cached-key x) (cached-key y))]
                 [(syntax->datum #'extract-key)
                  #'(less-than? (extract-key x) (extract-key y))]
                 [else #'(less-than? x y)]))
           ;; introsort body
           (let ([len (vector-length A)])
             (cond
               [(i≤ len 1) (void)]
               [else
                #,(maybe-cache-keys
                   (syntax->datum #'cache-keys?) #'extract-key #'A #'len)
                (letrec ([insertion-sort! #,(insertion-sort-def #'A #'<?)]
                         [select-pivot! #,(select-pivot-def #'A #'<?)]
                         [partition! #,(partition-def #'select-pivot! #'A #'<?)]
                         [heapsort! #,(heapsort-def #'A #'<?)]
                         [introsort! #,(introsort-def #'introsort!
                                                      #'partition!
                                                      #'insertion-sort!
                                                      #'heapsort!
                                                      #'A)])
                  (cond
                    ;; check if it's already sorted
                    [(for/and ([i (in-naturals)]
                               [j (in-range 1 len)])
                       (<? (vref A i) (vref A j)))
                     (void)]
                    ;; otherwise start the sorting!
                    [else
                     (introsort! 0 (i- len 1) (calc-max-depth len))]))
                #,(maybe-uncache-keys
                   (syntax->datum #'cache-keys?) #'A #'len)]))))]))

;; hashes storing precompiled versions for common
;; less-than comparators from racket/base

(define-values (precompiled-no-key-procs
                precompiled-no-caching-procs
                precompiled-caching-procs)
  (let ([no-key-hash (make-hasheq)]
        [no-caching-hash (make-hasheq)]
        [caching-hash (make-hasheq)])
    (define-syntax-rule (precompile! <? more ...)
      (let ([no-key-proc
             (λ (v) (introsort-body v <? #:key #f #:cache-keys? #f))]
            [no-caching-proc
             (λ (v extract-key)
               (introsort-body v <? #:key extract-key #:cache-keys? #f))]
            [caching-proc
             (λ (v extract-key)
               (introsort-body v <? #:key extract-key #:cache-keys? #t))])
        (begin
          (hash-set! no-key-hash <? no-key-proc)
          (hash-set! no-caching-hash <? no-caching-proc)
          (hash-set! caching-hash <? caching-proc))
        (begin
          (hash-set! no-key-hash more no-key-proc)
          (hash-set! no-caching-hash more no-caching-proc)
          (hash-set! caching-hash more caching-proc))
        ...))
    (precompile! unsafe-fx< unsafe-fx<=)
    (precompile! unsafe-fx> unsafe-fx>=)
    (precompile! < <=)
    (precompile! > >=)
    (precompile! string<? string<=?)
    (precompile! string-ci<? string-ci<=?)
    (precompile! keyword<?)
    (values
     (for/hasheq ([(k v) (in-hash no-key-hash)]) (values k v))
     (for/hasheq ([(k v) (in-hash no-caching-hash)]) (values k v))
     (for/hasheq ([(k v) (in-hash caching-hash)]) (values k v)))))

(define raw-vector-sort!
  (let ([generic-no-key-sort!
         (λ (v <?)
           (introsort-body v <? #:key #f #:cache-keys? #f))]
        [generic-no-caching-sort!
         (λ (v <? extract-key)
           (introsort-body v <? #:key extract-key #:cache-keys? #f))]
        [generic-caching-sort!
         (λ (v <? extract-key)
           (introsort-body v <? #:key extract-key #:cache-keys? #t))])
    (case-lambda
      [(v <?)
       (cond
         [(hash-ref precompiled-no-key-procs <? #f)
          => (λ (sort!) (sort! v))]
         [else (generic-no-key-sort! v <?)])]
      [(v <? extract-key cache?)
       (cond
         ;; they passed an extract-key... but it was values,
         ;; so just ignore it (and any caching option)
         [(eq? extract-key values)
          (cond
            [(hash-ref precompiled-no-key-procs <? #f)
             => (λ (sort!) (sort! v))]
            [else (generic-no-key-sort! v <?)])]
         [cache?
          (cond
            [(hash-ref precompiled-caching-procs <? #f)
             => (λ (sort!) (sort! v extract-key))]
            [else (generic-caching-sort! v <? extract-key)])]
         [(hash-ref precompiled-no-caching-procs <? #f)
          => (λ (sort!) (sort! v extract-key))]
         [else (generic-no-caching-sort! v <? extract-key)])])))

(define raw-vector-sort
  (case-lambda
    [(v <?)
     (let ([v (vector-copy v)])
       (raw-vector-sort! v <?)
       v)]
    [(v <? extract-key cache?)
     (let ([v (vector-copy v)])
       (raw-vector-sort! v <? extract-key cache?)
       v)]))
